<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herramienta de Flujos Hospitalarios</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        :root {
            --grid-size: 20px;
            --canvas-scale: 20;
            --canvas-width: 40;
            --canvas-height: 30;
            --selection-color: #2563eb;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #f4f7fb;
            color: #1f2937;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, #0ea5e9, #2563eb);
            color: white;
            padding: 24px 32px;
            box-shadow: 0 10px 30px rgba(37, 99, 235, 0.2);
        }

        header h1 {
            font-size: 1.9rem;
            font-weight: 700;
            margin: 0;
        }

        header p {
            margin: 8px 0 0;
            max-width: 760px;
            opacity: 0.95;
        }

        main {
            flex: 1;
            display: grid;
            grid-template-columns: 320px minmax(640px, 1fr) 320px;
            gap: 18px;
            padding: 24px;
        }

        .panel {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.08);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 18px 20px 14px;
            border-bottom: 1px solid #eef2f7;
        }

        .panel-header h2 {
            font-size: 1.05rem;
            font-weight: 600;
            margin: 0;
        }

        .panel-body {
            padding: 18px 20px;
            flex: 1;
            overflow-y: auto;
        }

        .category {
            margin-bottom: 18px;
        }

        .category-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            font-weight: 600;
            color: #1f2937;
        }

        .category-title span {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 6px;
        }

        .area-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 8px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            cursor: grab;
            transition: transform 0.18s ease, box-shadow 0.18s ease;
            font-size: 0.9rem;
        }

        .area-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
        }

        .area-item strong {
            font-weight: 600;
        }

        .area-item small {
            color: #64748b;
            font-size: 0.75rem;
        }

        #layout-panel {
            padding: 18px 20px 24px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .canvas-toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .canvas-toolbar .form-control,
        .canvas-toolbar .form-select {
            width: auto;
        }

        .canvas-container {
            flex: 1;
            border-radius: 18px;
            border: 1px solid #dbeafe;
            background: #f8fbff;
            padding: 16px;
            position: relative;
            overflow: auto;
        }

        #layout-canvas {
            position: relative;
            background-color: rgba(255, 255, 255, 0.92);
            background-image: linear-gradient(to right, rgba(148, 163, 184, 0.15) 1px, transparent 1px),
                              linear-gradient(to bottom, rgba(148, 163, 184, 0.15) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.3);
        }

        #layout-svg {
            position: absolute;
            top: 0;
            left: 0;
        }

        .area-shape {
            cursor: pointer;
            transition: filter 0.18s ease;
        }

        .area-shape:hover {
            filter: brightness(1.05);
        }

        .area-label {
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
        }

        #interaction-layer {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        .selection-box {
            position: absolute;
            border: 2px dashed var(--selection-color);
            border-radius: 6px;
            pointer-events: none;
        }

        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--selection-color);
            border-radius: 50%;
            border: 2px solid #fff;
            transform: translate(-50%, -50%);
            pointer-events: all;
            cursor: pointer;
        }

        .vertex-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #f97316;
            border-radius: 50%;
            border: 2px solid #fff;
            transform: translate(-50%, -50%);
            pointer-events: all;
            cursor: grab;
        }

        .properties-grid {
            display: grid;
            gap: 12px;
        }

        .properties-grid label {
            font-size: 0.85rem;
            font-weight: 500;
            color: #475569;
        }

        .properties-grid input,
        .properties-grid textarea,
        .properties-grid select {
            width: 100%;
        }

        .properties-grid textarea {
            resize: vertical;
            min-height: 80px;
        }

        .placeholder-message {
            text-align: center;
            color: #94a3b8;
            padding: 40px 20px;
            border: 1px dashed #cbd5f5;
            border-radius: 12px;
            background: #f8fafc;
        }

        .badge-category {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            font-size: 0.8rem;
            padding: 6px 10px;
            border-radius: 999px;
            color: #0f172a;
            background: rgba(148, 163, 184, 0.18);
        }

        .image-tools {
            display: grid;
            gap: 12px;
        }

        .image-preview {
            position: relative;
            background: #0f172a;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }

        .image-preview img {
            max-width: 100%;
            display: block;
        }

        .mode-indicator {
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(59, 130, 246, 0.12);
            border: 1px solid rgba(59, 130, 246, 0.22);
            color: #1d4ed8;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .tool-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tool-buttons button {
            flex: 1;
            min-width: 120px;
        }

        .legend {
            margin-top: 16px;
            display: grid;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.85rem;
            padding: 6px 10px;
            border-radius: 8px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
        }

        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 6px;
        }

        .scale-indicator {
            font-size: 0.85rem;
            color: #475569;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #f8fafc;
            border-radius: 999px;
            padding: 6px 12px;
            font-weight: 500;
            font-size: 0.85rem;
            color: #0f172a;
            border: 1px solid #e2e8f0;
        }

        .status-pill span {
            font-weight: 600;
        }

        .selected-area-summary {
            margin-top: 16px;
            border: 1px solid #cbd5f5;
            border-radius: 12px;
            padding: 12px;
            background: rgba(219, 234, 254, 0.4);
            font-size: 0.85rem;
            display: grid;
            gap: 6px;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 1380px) {
            main {
                grid-template-columns: 1fr;
            }

            #layout-panel {
                order: -1;
            }
        }

        @media (max-width: 768px) {
            header {
                padding: 20px;
            }

            main {
                padding: 16px;
                gap: 16px;
            }

            .panel {
                border-radius: 12px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Herramienta Integral de Flujos Hospitalarios</h1>
        <p>Planifica, analiza y simula la operación de hospitales de campaña con un editor espacial detallado, trazado desde imágenes y control total de parámetros clínicos, logísticos, WASH e IPC.</p>
    </header>
    <main>
        <aside class="panel">
            <div class="panel-header">
                <h2>Biblioteca de Áreas</h2>
                <p class="mb-0 text-muted" style="font-size: 0.85rem;">Arrastra una zona al canvas para incorporarla al layout.</p>
            </div>
            <div class="panel-body" id="library-panel"></div>
        </aside>

        <section class="panel" id="layout-panel">
            <div class="canvas-toolbar">
                <div class="status-pill">
                    Dimensiones Canvas: <span id="canvas-dimensions">40 × 30 m</span>
                </div>
                <div class="status-pill">
                    Escala: <span id="scale-label">20 px/m</span>
                </div>
                <div class="d-flex align-items-center gap-2">
                    <label for="scale-range" class="form-label mb-0">Escala</label>
                    <input type="range" class="form-range" id="scale-range" min="5" max="80" value="20">
                </div>
                <div class="d-flex align-items-center gap-2">
                    <label for="canvas-width" class="form-label mb-0">Ancho (m)</label>
                    <input type="number" min="10" max="120" value="40" id="canvas-width" class="form-control form-control-sm" style="width:90px;">
                </div>
                <div class="d-flex align-items-center gap-2">
                    <label for="canvas-height" class="form-label mb-0">Alto (m)</label>
                    <input type="number" min="10" max="120" value="30" id="canvas-height" class="form-control form-control-sm" style="width:90px;">
                </div>
                <div>
                    <select id="mode-select" class="form-select form-select-sm">
                        <option value="select">Modo Selección</option>
                        <option value="draw-rect">Trazado rectangular</option>
                        <option value="draw-poly">Trazado poligonal</option>
                        <option value="calibrate">Calibrar escala</option>
                    </select>
                </div>
                <div>
                    <button class="btn btn-outline-primary btn-sm" id="reset-view">Reiniciar Vista</button>
                </div>
            </div>
            <div class="mode-indicator" id="mode-indicator">Modo actual: Selección</div>
            <div class="canvas-container">
                <div id="layout-canvas">
                    <svg id="layout-svg"></svg>
                    <div id="interaction-layer"></div>
                </div>
            </div>
        </section>

        <aside class="panel">
            <div class="panel-header">
                <h2>Propiedades del Área</h2>
            </div>
            <div class="panel-body">
                <div id="properties-placeholder" class="placeholder-message">
                    Selecciona un área para editar sus atributos clínicos y operativos.
                </div>
                <form id="properties-form" class="properties-grid hidden">
                    <div>
                        <label for="area-name">Nombre</label>
                        <input type="text" id="area-name" class="form-control" placeholder="Nombre personalizado">
                    </div>
                    <div class="d-flex gap-2">
                        <div>
                            <label for="area-width">Ancho (m)</label>
                            <input type="number" step="0.5" min="1" id="area-width" class="form-control">
                        </div>
                        <div>
                            <label for="area-height">Alto (m)</label>
                            <input type="number" step="0.5" min="1" id="area-height" class="form-control">
                        </div>
                    </div>
                    <div class="d-flex gap-2">
                        <div>
                            <label for="area-capacity">Capacidad (pacientes)</label>
                            <input type="number" min="0" id="area-capacity" class="form-control">
                        </div>
                        <div>
                            <label for="area-process">Tiempo de proceso (min)</label>
                            <input type="number" min="0" id="area-process" class="form-control">
                        </div>
                    </div>
                    <div>
                        <label for="area-wait">Tiempo de espera esperado (min)</label>
                        <input type="number" min="0" id="area-wait" class="form-control">
                    </div>
                    <div>
                        <label for="area-category">Categoría</label>
                        <select id="area-category" class="form-select"></select>
                    </div>
                    <div>
                        <label for="area-type">Tipo</label>
                        <select id="area-type" class="form-select"></select>
                    </div>
                    <div>
                        <label for="area-color">Color personalizado</label>
                        <input type="color" id="area-color" class="form-control form-control-color" value="#60A5FA">
                    </div>
                    <div>
                        <label for="area-notes">Notas / observaciones</label>
                        <textarea id="area-notes" class="form-control" placeholder="Equipamiento, personal requerido, etc."></textarea>
                    </div>
                    <div class="d-flex gap-2 mt-2">
                        <button type="button" class="btn btn-danger flex-fill" id="delete-area">Eliminar área</button>
                        <button type="button" class="btn btn-outline-secondary" id="duplicate-area">Duplicar</button>
                    </div>
                </form>
                <div id="selected-summary" class="selected-area-summary hidden"></div>
            </div>
        </aside>
    </main>

    <section class="panel" style="margin: 0 24px 24px;">
        <div class="panel-header">
            <h2>Transformación de Imágenes a Layout</h2>
            <p class="mb-0 text-muted" style="font-size:0.9rem;">Carga planos existentes, calibra la escala y digitaliza espacios con asistencia visual.</p>
        </div>
        <div class="panel-body image-tools">
            <div class="row g-4">
                <div class="col-lg-4">
                    <label class="form-label">Importar plano (PNG, JPG, PDF)</label>
                    <input type="file" accept="image/png,image/jpeg,application/pdf" class="form-control" id="image-input">
                    <small class="text-muted">Para PDF se mostrará la primera página renderizada.</small>
                    <div class="mt-3">
                        <label for="image-opacity" class="form-label">Opacidad de fondo</label>
                        <input type="range" class="form-range" id="image-opacity" min="10" max="100" value="60">
                    </div>
                    <div class="scale-indicator" id="calibration-info">Sin calibración activa.</div>
                </div>
                <div class="col-lg-4">
                    <div class="tool-buttons">
                        <button class="btn btn-outline-primary" id="btn-calibrate">Iniciar calibración</button>
                        <button class="btn btn-outline-secondary" id="btn-draw-rect">Rectángulos asistidos</button>
                        <button class="btn btn-outline-secondary" id="btn-draw-poly">Polígonos asistidos</button>
                    </div>
                    <p class="text-muted mt-3" style="font-size:0.85rem;">1. Carga la imagen · 2. Selecciona dos puntos con distancia conocida · 3. Introduce los metros reales · 4. Traza áreas siguiendo el contorno con snapping magnético a la grilla.</p>
                    <div class="legend" id="category-legend"></div>
                </div>
                <div class="col-lg-4">
                    <div class="badge text-bg-light" id="image-status">Sin imagen cargada.</div>
                    <div class="mt-3">
                        <button class="btn btn-success w-100" id="export-layout">Exportar Layout JSON</button>
                    </div>
                    <p class="text-muted" style="font-size:0.85rem;">El JSON incluye todas las áreas, coordenadas en metros, atributos clínicos y metadatos de escala para análisis externos o integración con simulaciones.</p>
                </div>
            </div>
        </div>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
    <script>
        const CATEGORY_DEFINITIONS = [
            {
                key: 'wash',
                label: 'WASH',
                color: '#60A5FA',
                areas: [
                    'Área de tratamiento de agua',
                    'Letrinas (personal)',
                    'Letrinas (hospitalizados)',
                    'Letrinas (ambulatorios)',
                    'Gestión de lodos fecales',
                    'Estación de lavado de manos',
                    'Duchas (personal)',
                    'Duchas (pacientes)',
                    'Gestión de residuos',
                    'Almacenamiento de residuos',
                    'Segregación de residuos',
                    'Lavandería',
                    'Sala de limpieza',
                    'Morgue'
                ]
            },
            {
                key: 'ipc',
                label: 'IPC',
                color: '#34D399',
                areas: [
                    'Reprocesamiento',
                    'Esterilización',
                    'Almacenamiento IPC',
                    'Área de colocación de EPP (Donning)',
                    'Área de retirada de EPP (Doffing)'
                ]
            },
            {
                key: 'logistica',
                label: 'Logística',
                color: '#FBBF24',
                areas: [
                    'Comedor',
                    'Cocina',
                    'Almacenamiento general',
                    'Sala de energía',
                    'Almacén',
                    'Almacén de medicamentos'
                ]
            },
            {
                key: 'clinica',
                label: 'Clínica',
                color: '#F87171',
                areas: [
                    'Área de espera',
                    'Screening / Detección',
                    'Triage',
                    'Consulta externa',
                    'Sala de hospitalización',
                    'Sala de emergencias',
                    'Reanimación',
                    'Quirófano',
                    'Sala de partos',
                    'UCI',
                    'Farmacia',
                    'Laboratorio',
                    'Radiología',
                    'Área de recuperación'
                ]
            }
        ];

        const layoutCanvas = document.getElementById('layout-canvas');
        const layoutSvg = document.getElementById('layout-svg');
        const interactionLayer = document.getElementById('interaction-layer');
        const libraryPanel = document.getElementById('library-panel');
        const modeSelect = document.getElementById('mode-select');
        const modeIndicator = document.getElementById('mode-indicator');
        const scaleRange = document.getElementById('scale-range');
        const scaleLabel = document.getElementById('scale-label');
        const canvasWidthInput = document.getElementById('canvas-width');
        const canvasHeightInput = document.getElementById('canvas-height');
        const canvasDimensionsLabel = document.getElementById('canvas-dimensions');
        const propertiesForm = document.getElementById('properties-form');
        const propertiesPlaceholder = document.getElementById('properties-placeholder');
        const categoryLegend = document.getElementById('category-legend');
        const selectedSummary = document.getElementById('selected-summary');
        const imageInput = document.getElementById('image-input');
        const imageStatus = document.getElementById('image-status');
        const imageOpacity = document.getElementById('image-opacity');
        const calibrationInfo = document.getElementById('calibration-info');
        const btnCalibrate = document.getElementById('btn-calibrate');
        const btnDrawRect = document.getElementById('btn-draw-rect');
        const btnDrawPoly = document.getElementById('btn-draw-poly');
        const exportButton = document.getElementById('export-layout');
        const resetViewButton = document.getElementById('reset-view');

        const areaNameInput = document.getElementById('area-name');
        const areaWidthInput = document.getElementById('area-width');
        const areaHeightInput = document.getElementById('area-height');
        const areaCapacityInput = document.getElementById('area-capacity');
        const areaProcessInput = document.getElementById('area-process');
        const areaWaitInput = document.getElementById('area-wait');
        const areaCategorySelect = document.getElementById('area-category');
        const areaTypeSelect = document.getElementById('area-type');
        const areaColorInput = document.getElementById('area-color');
        const areaNotesInput = document.getElementById('area-notes');
        const deleteAreaButton = document.getElementById('delete-area');
        const duplicateAreaButton = document.getElementById('duplicate-area');

        const state = {
            scale: 20,
            widthMeters: 40,
            heightMeters: 30,
            areas: [],
            selectedAreaId: null,
            mode: 'select',
            dragContext: null,
            drawContext: null,
            calibrationPoints: [],
            backgroundImage: null
        };

        function init() {
            renderLibrary();
            renderLegend();
            populateCategorySelects();
            updateCanvasSize();
            attachEvents();
        }

        function renderLibrary() {
            libraryPanel.innerHTML = '';
            CATEGORY_DEFINITIONS.forEach(category => {
                const wrapper = document.createElement('div');
                wrapper.className = 'category';
                const title = document.createElement('div');
                title.className = 'category-title';
                const colorSwatch = document.createElement('span');
                colorSwatch.style.background = category.color;
                title.append(colorSwatch, document.createTextNode(category.label));
                wrapper.appendChild(title);

                category.areas.forEach(areaName => {
                    const item = document.createElement('div');
                    item.className = 'area-item';
                    item.draggable = true;
                    item.dataset.category = category.key;
                    item.dataset.color = category.color;
                    item.dataset.areaName = areaName;
                    item.innerHTML = `<strong>${areaName}</strong>`;
                    item.addEventListener('dragstart', onLibraryDragStart);
                    wrapper.appendChild(item);
                });

                libraryPanel.appendChild(wrapper);
            });
        }

        function renderLegend() {
            categoryLegend.innerHTML = '';
            CATEGORY_DEFINITIONS.forEach(category => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<span>${category.label}</span>`;
                const color = document.createElement('div');
                color.className = 'legend-color';
                color.style.background = category.color;
                item.appendChild(color);
                categoryLegend.appendChild(item);
            });
        }

        function populateCategorySelects() {
            areaCategorySelect.innerHTML = '';
            CATEGORY_DEFINITIONS.forEach(category => {
                const option = document.createElement('option');
                option.value = category.key;
                option.textContent = category.label;
                areaCategorySelect.appendChild(option);
            });
        }

        function populateAreaTypes(categoryKey) {
            const category = CATEGORY_DEFINITIONS.find(c => c.key === categoryKey) || CATEGORY_DEFINITIONS[0];
            areaTypeSelect.innerHTML = '';
            category.areas.forEach(area => {
                const option = document.createElement('option');
                option.value = area;
                option.textContent = area;
                areaTypeSelect.appendChild(option);
            });
        }

        function onLibraryDragStart(event) {
            event.dataTransfer.setData('application/json', JSON.stringify({
                category: event.target.dataset.category,
                color: event.target.dataset.color,
                name: event.target.dataset.areaName
            }));
        }

        function attachEvents() {
            layoutCanvas.addEventListener('dragover', event => event.preventDefault());
            layoutCanvas.addEventListener('drop', onCanvasDrop);
            layoutCanvas.addEventListener('pointerdown', onCanvasPointerDown);
            layoutCanvas.addEventListener('pointermove', onCanvasPointerMove);
            layoutCanvas.addEventListener('pointerup', onCanvasPointerUp);
            layoutCanvas.addEventListener('pointerleave', onCanvasPointerUp);

            modeSelect.addEventListener('change', () => setMode(modeSelect.value));
            scaleRange.addEventListener('input', () => {
                state.scale = Number(scaleRange.value);
                scaleLabel.textContent = `${state.scale} px/m`;
                updateCanvasSize();
                renderAreas();
                updateSelectionOverlay();
            });

            canvasWidthInput.addEventListener('change', () => {
                const value = Math.max(10, Math.min(120, Number(canvasWidthInput.value)));
                state.widthMeters = value;
                canvasWidthInput.value = value;
                canvasDimensionsLabel.textContent = `${state.widthMeters} × ${state.heightMeters} m`;
                updateCanvasSize();
                renderAreas();
                updateSelectionOverlay();
            });

            canvasHeightInput.addEventListener('change', () => {
                const value = Math.max(10, Math.min(120, Number(canvasHeightInput.value)));
                state.heightMeters = value;
                canvasHeightInput.value = value;
                canvasDimensionsLabel.textContent = `${state.widthMeters} × ${state.heightMeters} m`;
                updateCanvasSize();
                renderAreas();
                updateSelectionOverlay();
            });

            areaCategorySelect.addEventListener('change', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.category = areaCategorySelect.value;
                populateAreaTypes(area.category);
                if (!CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.areas.includes(area.type)) {
                    area.type = CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.areas[0] || area.type;
                }
                const baseColor = CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.color;
                if (baseColor) {
                    area.baseColor = baseColor;
                    if (!area.customColor) {
                        area.color = baseColor;
                        areaColorInput.value = baseColor;
                    }
                }
                renderAreas();
                updateSelectedSummary();
            });

            areaTypeSelect.addEventListener('change', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.type = areaTypeSelect.value;
                renderAreas();
                updateSelectedSummary();
            });
            areaNameInput.addEventListener('input', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.name = areaNameInput.value;
                renderAreas();
                updateSelectedSummary();
            });

            areaWidthInput.addEventListener('change', () => updateDimensionsFromInputs());
            areaHeightInput.addEventListener('change', () => updateDimensionsFromInputs());

            areaCapacityInput.addEventListener('change', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.capacity = Number(areaCapacityInput.value) || 0;
                updateSelectedSummary();
            });

            areaProcessInput.addEventListener('change', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.processTime = Number(areaProcessInput.value) || 0;
                updateSelectedSummary();
            });

            areaWaitInput.addEventListener('change', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.waitTime = Number(areaWaitInput.value) || 0;
                updateSelectedSummary();
            });

            areaColorInput.addEventListener('input', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.color = areaColorInput.value;
                area.customColor = true;
                renderAreas();
            });

            areaNotesInput.addEventListener('input', () => {
                const area = getSelectedArea();
                if (!area) return;
                area.notes = areaNotesInput.value;
                updateSelectedSummary();
            });

            deleteAreaButton.addEventListener('click', () => {
                if (!state.selectedAreaId) return;
                state.areas = state.areas.filter(area => area.id !== state.selectedAreaId);
                state.selectedAreaId = null;
                renderAreas();
                updateSelectionOverlay();
                updatePropertiesVisibility();
            });

            duplicateAreaButton.addEventListener('click', () => {
                const area = getSelectedArea();
                if (!area) return;
                const cloneFn = typeof structuredClone === 'function'
                    ? structuredClone
                    : value => JSON.parse(JSON.stringify(value));
                const copy = cloneFn(area);
                copy.id = crypto.randomUUID();
                if (area.shape === 'rect') {
                    copy.x = clamp(area.x + 1, 0, state.widthMeters - area.width);
                    copy.y = clamp(area.y + 1, 0, state.heightMeters - area.height);
                } else if (area.shape === 'polygon') {
                    copy.points = area.points.map(point => ({
                        x: clamp(point.x + 1, 0, state.widthMeters),
                        y: clamp(point.y + 1, 0, state.heightMeters)
                    }));
                }
                copy.name = `${area.name || area.type} (copia)`;
                state.areas.push(copy);
                selectArea(copy.id);
                renderAreas();
            });

            imageOpacity.addEventListener('input', () => {
                layoutCanvas.style.backgroundColor = `rgba(255,255,255,${Number(imageOpacity.value) / 100})`;
            });

            imageInput.addEventListener('change', handleImageUpload);
            btnCalibrate.addEventListener('click', () => setMode('calibrate'));
            btnDrawRect.addEventListener('click', () => setMode('draw-rect'));
            btnDrawPoly.addEventListener('click', () => setMode('draw-poly'));
            exportButton.addEventListener('click', exportLayoutAsJson);
            resetViewButton.addEventListener('click', () => {
                state.scale = 20;
                scaleRange.value = 20;
                scaleLabel.textContent = `${state.scale} px/m`;
                updateCanvasSize();
                renderAreas();
                updateSelectionOverlay();
            });
        }

        function updateCanvasSize() {
            const widthPx = state.widthMeters * state.scale;
            const heightPx = state.heightMeters * state.scale;
            layoutCanvas.style.width = `${widthPx}px`;
            layoutCanvas.style.height = `${heightPx}px`;
            layoutSvg.setAttribute('width', widthPx);
            layoutSvg.setAttribute('height', heightPx);
            layoutSvg.style.width = `${widthPx}px`;
            layoutSvg.style.height = `${heightPx}px`;
            layoutCanvas.style.setProperty('--grid-size', `${state.scale}px`);
            modeIndicator.textContent = `Modo actual: ${translateMode(state.mode)}`;
        }

        function translateMode(mode) {
            switch (mode) {
                case 'select': return 'Selección';
                case 'draw-rect': return 'Trazado rectangular';
                case 'draw-poly': return 'Trazado poligonal';
                case 'calibrate': return 'Calibración de escala';
                default: return mode;
            }
        }

        function setMode(mode) {
            state.mode = mode;
            modeSelect.value = mode;
            modeIndicator.textContent = `Modo actual: ${translateMode(mode)}`;
            if (mode !== 'draw-poly') {
                state.drawContext = null;
                removeTempDrawing();
            }
            if (mode !== 'calibrate') {
                state.calibrationPoints = [];
                calibrationInfo.textContent = 'Sin calibración activa.';
            } else {
                calibrationInfo.textContent = 'Haz clic en dos puntos del plano y luego introduce la distancia real.';
            }
        }
        function onCanvasDrop(event) {
            event.preventDefault();
            const data = event.dataTransfer.getData('application/json');
            if (!data) return;
            const payload = JSON.parse(data);
            const rect = layoutCanvas.getBoundingClientRect();
            const dropX = (event.clientX - rect.left) / state.scale;
            const dropY = (event.clientY - rect.top) / state.scale;
            const area = createArea({
                shape: 'rect',
                x: snap(dropX - 2),
                y: snap(dropY - 2),
                width: 4,
                height: 4,
                category: payload.category,
                type: payload.name,
                color: payload.color,
                baseColor: payload.color,
                name: payload.name,
                capacity: 0,
                processTime: 0,
                waitTime: 0,
                notes: ''
            });
            state.areas.push(area);
            selectArea(area.id);
            renderAreas();
        }

        function createArea(partial) {
            return {
                id: crypto.randomUUID(),
                shape: partial.shape || 'rect',
                x: partial.x ?? 0,
                y: partial.y ?? 0,
                width: partial.width ?? 4,
                height: partial.height ?? 4,
                points: partial.points || [],
                category: partial.category || CATEGORY_DEFINITIONS[0].key,
                type: partial.type || CATEGORY_DEFINITIONS[0].areas[0],
                color: partial.color || CATEGORY_DEFINITIONS[0].color,
                baseColor: partial.baseColor || CATEGORY_DEFINITIONS[0].color,
                name: partial.name || '',
                capacity: partial.capacity || 0,
                processTime: partial.processTime || 0,
                waitTime: partial.waitTime || 0,
                notes: partial.notes || '',
                customColor: partial.customColor || false
            };
        }

        function renderAreas() {
            layoutSvg.innerHTML = '';
            state.areas.forEach(area => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.classList.add('area-shape');
                group.dataset.id = area.id;
                group.addEventListener('pointerdown', event => onAreaPointerDown(event, area));

                const fill = area.color || CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.color || '#94a3b8';
                const stroke = area.id === state.selectedAreaId ? '#1d4ed8' : '#1f2937';

                if (area.shape === 'rect') {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', area.x * state.scale);
                    rect.setAttribute('y', area.y * state.scale);
                    rect.setAttribute('width', area.width * state.scale);
                    rect.setAttribute('height', area.height * state.scale);
                    rect.setAttribute('rx', 6);
                    rect.setAttribute('fill', fill);
                    rect.setAttribute('fill-opacity', 0.85);
                    rect.setAttribute('stroke', stroke);
                    rect.setAttribute('stroke-width', area.id === state.selectedAreaId ? 2.4 : 1.2);
                    group.appendChild(rect);
                } else if (area.shape === 'polygon') {
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const points = area.points.map(point => `${point.x * state.scale},${point.y * state.scale}`).join(' ');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('fill', fill);
                    polygon.setAttribute('fill-opacity', 0.82);
                    polygon.setAttribute('stroke', stroke);
                    polygon.setAttribute('stroke-width', area.id === state.selectedAreaId ? 2.4 : 1.2);
                    group.appendChild(polygon);
                }

                const centroid = getAreaCentroid(area);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.classList.add('area-label');
                label.setAttribute('fill', '#0f172a');
                label.setAttribute('x', centroid.x * state.scale);
                label.setAttribute('y', centroid.y * state.scale);
                label.setAttribute('dominant-baseline', 'middle');
                label.setAttribute('text-anchor', 'middle');
                label.textContent = area.name || area.type;
                group.appendChild(label);

                layoutSvg.appendChild(group);
            });
        }

        function onAreaPointerDown(event, area) {
            event.stopPropagation();
            selectArea(area.id);
            if (state.mode !== 'select') {
                if (state.mode === 'calibrate') {
                    handleCalibrationClick(event);
                }
                return;
            }
            const pointer = getPointerPosition(event);
            if (area.shape === 'rect') {
                state.dragContext = {
                    type: 'move-rect',
                    areaId: area.id,
                    startX: pointer.x,
                    startY: pointer.y,
                    originX: area.x,
                    originY: area.y
                };
            } else if (area.shape === 'polygon') {
                state.dragContext = {
                    type: 'move-polygon',
                    areaId: area.id,
                    startX: pointer.x,
                    startY: pointer.y,
                    points: area.points.map(point => ({ ...point }))
                };
            }
            layoutCanvas.setPointerCapture(event.pointerId);
        }

        function getPointerPosition(event) {
            const rect = layoutCanvas.getBoundingClientRect();
            return {
                x: (event.clientX - rect.left) / state.scale,
                y: (event.clientY - rect.top) / state.scale
            };
        }
        function onCanvasPointerDown(event) {
            if (event.target === layoutCanvas || event.target === interactionLayer || event.target === layoutSvg) {
                if (state.mode === 'select') {
                    clearSelection();
                    return;
                }
                if (state.mode === 'calibrate') {
                    handleCalibrationClick(event);
                    return;
                }
                if (state.mode === 'draw-rect') {
                    const start = getPointerPosition(event);
                    state.drawContext = {
                        type: 'rect',
                        startX: snap(start.x),
                        startY: snap(start.y),
                        currentX: snap(start.x),
                        currentY: snap(start.y)
                    };
                    createTempRectangle();
                } else if (state.mode === 'draw-poly') {
                    handlePolygonDrawing(event);
                }
            }
        }

        function onCanvasPointerMove(event) {
            if (state.mode === 'calibrate' && state.calibrationPoints.length === 1) {
                updateCalibrationPreview(event);
                return;
            }

            if (state.drawContext?.type === 'rect' && state.mode === 'draw-rect') {
                const current = getPointerPosition(event);
                state.drawContext.currentX = snap(current.x);
                state.drawContext.currentY = snap(current.y);
                updateTempRectangle();
                return;
            }

            if (state.dragContext) {
                const pointer = getPointerPosition(event);
                const area = state.areas.find(a => a.id === state.dragContext.areaId);
                if (!area) return;

                if (state.dragContext.type === 'move-rect') {
                    const dx = pointer.x - state.dragContext.startX;
                    const dy = pointer.y - state.dragContext.startY;
                    area.x = clamp(snap(state.dragContext.originX + dx), 0, state.widthMeters - area.width);
                    area.y = clamp(snap(state.dragContext.originY + dy), 0, state.heightMeters - area.height);
                    renderAreas();
                    updateSelectionOverlay();
                    updateFormDimensions(area);
                } else if (state.dragContext.type === 'resize-rect') {
                    handleRectangleResize(area, pointer);
                } else if (state.dragContext.type === 'move-polygon') {
                    const dx = pointer.x - state.dragContext.startX;
                    const dy = pointer.y - state.dragContext.startY;
                    area.points = state.dragContext.points.map(point => ({
                        x: clamp(snap(point.x + dx), 0, state.widthMeters),
                        y: clamp(snap(point.y + dy), 0, state.heightMeters)
                    }));
                    renderAreas();
                    updateSelectionOverlay();
                } else if (state.dragContext.type === 'vertex-move') {
                    const { vertexIndex } = state.dragContext;
                    area.points[vertexIndex] = {
                        x: clamp(snap(pointer.x), 0, state.widthMeters),
                        y: clamp(snap(pointer.y), 0, state.heightMeters)
                    };
                    renderAreas();
                    updateSelectionOverlay();
                }
                event.preventDefault();
            }
        }

        function onCanvasPointerUp(event) {
            if (state.mode === 'draw-rect' && state.drawContext?.type === 'rect') {
                const { startX, startY, currentX, currentY } = state.drawContext;
                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);
                if (width >= 1 && height >= 1) {
                    const area = createArea({
                        shape: 'rect',
                        x: Math.min(startX, currentX),
                        y: Math.min(startY, currentY),
                        width,
                        height,
                        name: 'Nueva área',
                        type: CATEGORY_DEFINITIONS[0].areas[0],
                        category: CATEGORY_DEFINITIONS[0].key,
                        color: CATEGORY_DEFINITIONS[0].color,
                        baseColor: CATEGORY_DEFINITIONS[0].color
                    });
                    state.areas.push(area);
                    selectArea(area.id);
                    renderAreas();
                }
                state.drawContext = null;
                removeTempDrawing();
            }

            if (state.dragContext) {
                state.dragContext = null;
                if (event.pointerId !== undefined) {
                    try {
                        layoutCanvas.releasePointerCapture(event.pointerId);
                    } catch (error) {
                        console.warn('No pointer capture to release', error);
                    }
                }
            }
        }
        function handleRectangleResize(area, pointer) {
            const { handle, origin } = state.dragContext;
            let { x, y, width, height } = origin;
            if (handle.includes('e')) {
                const newWidth = snap(pointer.x - x);
                if (newWidth >= 1) {
                    width = Math.min(newWidth, state.widthMeters - x);
                }
            }
            if (handle.includes('s')) {
                const newHeight = snap(pointer.y - y);
                if (newHeight >= 1) {
                    height = Math.min(newHeight, state.heightMeters - y);
                }
            }
            if (handle.includes('w')) {
                const newX = snap(pointer.x);
                const delta = x - newX;
                if (width + delta >= 1) {
                    x = Math.max(0, newX);
                    width += delta;
                }
            }
            if (handle.includes('n')) {
                const newY = snap(pointer.y);
                const delta = y - newY;
                if (height + delta >= 1) {
                    y = Math.max(0, newY);
                    height += delta;
                }
            }
            area.x = clamp(x, 0, state.widthMeters - 1);
            area.y = clamp(y, 0, state.heightMeters - 1);
            area.width = clamp(width, 1, state.widthMeters - area.x);
            area.height = clamp(height, 1, state.heightMeters - area.y);
            renderAreas();
            updateSelectionOverlay();
            updateFormDimensions(area);
        }

        function updateDimensionsFromInputs() {
            const area = getSelectedArea();
            if (!area || area.shape !== 'rect') return;
            const width = Math.max(1, Number(areaWidthInput.value));
            const height = Math.max(1, Number(areaHeightInput.value));
            area.width = snap(width);
            area.height = snap(height);
            area.x = Math.min(area.x, state.widthMeters - area.width);
            area.y = Math.min(area.y, state.heightMeters - area.height);
            renderAreas();
            updateSelectionOverlay();
        }

        function updateFormDimensions(area) {
            if (area.shape === 'rect') {
                areaWidthInput.value = area.width;
                areaHeightInput.value = area.height;
            }
        }

        function selectArea(areaId) {
            state.selectedAreaId = areaId;
            const area = getSelectedArea();
            updatePropertiesVisibility();
            if (area) {
                populateAreaTypes(area.category);
                areaCategorySelect.value = area.category;
                if (!CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.areas.includes(area.type)) {
                    area.type = CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.areas[0];
                }
                areaTypeSelect.value = area.type;
                areaNameInput.value = area.name;
                areaCapacityInput.value = area.capacity;
                areaProcessInput.value = area.processTime;
                areaWaitInput.value = area.waitTime;
                areaColorInput.value = area.color;
                areaNotesInput.value = area.notes;
                if (area.shape === 'rect') {
                    areaWidthInput.value = area.width;
                    areaHeightInput.value = area.height;
                    areaWidthInput.disabled = false;
                    areaHeightInput.disabled = false;
                } else {
                    areaWidthInput.value = '';
                    areaHeightInput.value = '';
                    areaWidthInput.disabled = true;
                    areaHeightInput.disabled = true;
                }
            }
            renderAreas();
            updateSelectionOverlay();
            updateSelectedSummary();
        }

        function updatePropertiesVisibility() {
            const area = getSelectedArea();
            if (area) {
                propertiesPlaceholder.classList.add('hidden');
                propertiesForm.classList.remove('hidden');
                selectedSummary.classList.remove('hidden');
            } else {
                propertiesPlaceholder.classList.remove('hidden');
                propertiesForm.classList.add('hidden');
                selectedSummary.classList.add('hidden');
            }
        }

        function updateSelectedSummary() {
            const area = getSelectedArea();
            if (!area) return;
            const areaTypeLabel = CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.label || area.category;
            selectedSummary.innerHTML = `
                <div><strong>Nombre:</strong> ${area.name || 'Sin nombre'}</div>
                <div><strong>Tipo:</strong> ${area.type}</div>
                <div><strong>Categoría:</strong> ${areaTypeLabel}</div>
                <div><strong>Dimensiones:</strong> ${area.shape === 'rect' ? `${area.width} × ${area.height} m` : `${area.points.length} vértices`}</div>
                <div><strong>Capacidad:</strong> ${area.capacity} pacientes</div>
                <div><strong>T. proceso:</strong> ${area.processTime} min · <strong>T. espera:</strong> ${area.waitTime} min</div>
                <div><strong>Notas:</strong> ${area.notes || '—'}</div>
            `;
        }

        function clearSelection() {
            state.selectedAreaId = null;
            renderAreas();
            updateSelectionOverlay();
            updatePropertiesVisibility();
        }

        function getSelectedArea() {
            return state.areas.find(area => area.id === state.selectedAreaId) || null;
        }

        function snap(value) {
            return Math.round(value);
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        function updateSelectionOverlay() {
            interactionLayer.innerHTML = '';
            const area = getSelectedArea();
            if (!area) return;
            if (area.shape === 'rect') {
                const box = document.createElement('div');
                box.className = 'selection-box';
                box.style.left = `${area.x * state.scale}px`;
                box.style.top = `${area.y * state.scale}px`;
                box.style.width = `${area.width * state.scale}px`;
                box.style.height = `${area.height * state.scale}px`;
                interactionLayer.appendChild(box);
                ['nw', 'ne', 'sw', 'se'].forEach(handle => {
                    const handleEl = document.createElement('div');
                    handleEl.className = 'resize-handle';
                    handleEl.dataset.handle = handle;
                    positionHandle(handleEl, area);
                    handleEl.addEventListener('pointerdown', event => startResize(event, area, handle));
                    interactionLayer.appendChild(handleEl);
                });
            } else if (area.shape === 'polygon') {
                const bounds = getPolygonBounds(area.points);
                const box = document.createElement('div');
                box.className = 'selection-box';
                box.style.left = `${bounds.x * state.scale}px`;
                box.style.top = `${bounds.y * state.scale}px`;
                box.style.width = `${bounds.width * state.scale}px`;
                box.style.height = `${bounds.height * state.scale}px`;
                interactionLayer.appendChild(box);
                area.points.forEach((point, index) => {
                    const handleEl = document.createElement('div');
                    handleEl.className = 'vertex-handle';
                    handleEl.style.left = `${point.x * state.scale}px`;
                    handleEl.style.top = `${point.y * state.scale}px`;
                    handleEl.addEventListener('pointerdown', event => startVertexMove(event, area, index));
                    interactionLayer.appendChild(handleEl);
                });
            }
        }

        function positionHandle(handleEl, area) {
            const positions = {
                nw: { left: area.x, top: area.y },
                ne: { left: area.x + area.width, top: area.y },
                sw: { left: area.x, top: area.y + area.height },
                se: { left: area.x + area.width, top: area.y + area.height }
            };
            const pos = positions[handleEl.dataset.handle];
            handleEl.style.left = `${pos.left * state.scale}px`;
            handleEl.style.top = `${pos.top * state.scale}px`;
        }

        function startResize(event, area, handle) {
            event.stopPropagation();
            state.dragContext = {
                type: 'resize-rect',
                areaId: area.id,
                handle,
                origin: { x: area.x, y: area.y, width: area.width, height: area.height }
            };
            layoutCanvas.setPointerCapture(event.pointerId);
        }

        function startVertexMove(event, area, index) {
            event.stopPropagation();
            state.dragContext = {
                type: 'vertex-move',
                areaId: area.id,
                vertexIndex: index
            };
            layoutCanvas.setPointerCapture(event.pointerId);
        }

        function getPolygonBounds(points) {
            const xs = points.map(point => point.x);
            const ys = points.map(point => point.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
        }

        function getAreaCentroid(area) {
            if (area.shape === 'rect') {
                return { x: area.x + area.width / 2, y: area.y + area.height / 2 };
            }
            let signedArea = 0;
            let cx = 0;
            let cy = 0;
            const points = area.points;
            for (let i = 0; i < points.length; i++) {
                const current = points[i];
                const next = points[(i + 1) % points.length];
                const a = current.x * next.y - next.x * current.y;
                signedArea += a;
                cx += (current.x + next.x) * a;
                cy += (current.y + next.y) * a;
            }
            signedArea *= 0.5;
            if (signedArea === 0) {
                return points[0] || { x: 0, y: 0 };
            }
            cx /= (6 * signedArea);
            cy /= (6 * signedArea);
            return { x: cx, y: cy };
        }

        function handlePolygonDrawing(event) {
            const point = getPointerPosition(event);
            if (!state.drawContext) {
                state.drawContext = {
                    type: 'polygon',
                    points: [snapPoint(point)]
                };
                createTempPolygon();
            } else {
                const lastPoint = state.drawContext.points[state.drawContext.points.length - 1];
                const snappedPoint = snapPoint(point);
                if (distanceBetween(lastPoint, snappedPoint) >= 0.5) {
                    state.drawContext.points.push(snappedPoint);
                    updateTempPolygon();
                }
            }

            if (event.detail === 2 && state.drawContext?.points.length >= 3) {
                const polygonArea = createArea({
                    shape: 'polygon',
                    points: state.drawContext.points,
                    name: 'Área poligonal',
                    type: CATEGORY_DEFINITIONS[0].areas[0],
                    category: CATEGORY_DEFINITIONS[0].key,
                    color: CATEGORY_DEFINITIONS[0].color,
                    baseColor: CATEGORY_DEFINITIONS[0].color
                });
                state.areas.push(polygonArea);
                selectArea(polygonArea.id);
                renderAreas();
                state.drawContext = null;
                removeTempDrawing();
            }
        }

        function snapPoint(point) {
            return { x: snap(point.x), y: snap(point.y) };
        }

        function distanceBetween(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function createTempRectangle() {
            removeTempDrawing();
            const temp = document.createElement('div');
            temp.id = 'temp-rect';
            temp.style.position = 'absolute';
            temp.style.border = '1px dashed #1d4ed8';
            temp.style.background = 'rgba(59,130,246,0.15)';
            temp.style.pointerEvents = 'none';
            layoutCanvas.appendChild(temp);
        }

        function updateTempRectangle() {
            const temp = document.getElementById('temp-rect');
            if (!temp || !state.drawContext) return;
            const { startX, startY, currentX, currentY } = state.drawContext;
            const x = Math.min(startX, currentX) * state.scale;
            const y = Math.min(startY, currentY) * state.scale;
            const width = Math.abs(currentX - startX) * state.scale;
            const height = Math.abs(currentY - startY) * state.scale;
            temp.style.left = `${x}px`;
            temp.style.top = `${y}px`;
            temp.style.width = `${width}px`;
            temp.style.height = `${height}px`;
        }

        function createTempPolygon() {
            removeTempDrawing();
            const temp = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            temp.id = 'temp-poly';
            temp.setAttribute('fill', 'rgba(59,130,246,0.15)');
            temp.setAttribute('stroke', '#2563eb');
            temp.setAttribute('stroke-dasharray', '6 4');
            temp.setAttribute('stroke-width', '2');
            layoutSvg.appendChild(temp);
        }

        function updateTempPolygon() {
            const temp = document.getElementById('temp-poly');
            if (!temp || !state.drawContext) return;
            const points = state.drawContext.points.map(point => `${point.x * state.scale},${point.y * state.scale}`).join(' ');
            temp.setAttribute('points', points);
        }

        function removeTempDrawing() {
            const tempRect = document.getElementById('temp-rect');
            if (tempRect) tempRect.remove();
            const tempPoly = document.getElementById('temp-poly');
            if (tempPoly) tempPoly.remove();
        }
        function handleCalibrationClick(event) {
            const point = getPointerPosition(event);
            state.calibrationPoints.push({ x: point.x, y: point.y });
            if (state.calibrationPoints.length === 2) {
                const [p1, p2] = state.calibrationPoints;
                const distancePx = distanceBetween(p1, p2) * state.scale;
                const realDistance = Number(prompt('Introduce la distancia real entre los puntos (en metros):', '10'));
                if (realDistance && realDistance > 0) {
                    const computedScale = distancePx / realDistance;
                    state.scale = clamp(computedScale, Number(scaleRange.min), Number(scaleRange.max));
                    scaleRange.value = Math.round(state.scale);
                    scaleLabel.textContent = `${state.scale.toFixed(1)} px/m`;
                    updateCanvasSize();
                    renderAreas();
                    updateSelectionOverlay();
                    calibrationInfo.textContent = `Calibrado: 1 m = ${state.scale.toFixed(2)} px`;
                }
                state.calibrationPoints = [];
                removeCalibrationPreview();
                setMode('select');
            } else {
                calibrationInfo.textContent = 'Selecciona el segundo punto de referencia.';
            }
        }

        function updateCalibrationPreview(event) {
            removeCalibrationPreview();
            const start = state.calibrationPoints[0];
            const current = getPointerPosition(event);
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.id = 'calibration-line';
            line.setAttribute('x1', start.x * state.scale);
            line.setAttribute('y1', start.y * state.scale);
            line.setAttribute('x2', snap(current.x) * state.scale);
            line.setAttribute('y2', snap(current.y) * state.scale);
            line.setAttribute('stroke', '#f97316');
            line.setAttribute('stroke-width', '2');
            line.setAttribute('stroke-dasharray', '4 3');
            layoutSvg.appendChild(line);
        }

        function removeCalibrationPreview() {
            const line = document.getElementById('calibration-line');
            if (line) line.remove();
        }

        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (file.type === 'application/pdf') {
                await renderPdfToCanvas(file);
                return;
            }
            const reader = new FileReader();
            reader.onload = e => {
                layoutCanvas.style.backgroundImage = `url(${e.target.result})`;
                layoutCanvas.style.backgroundSize = 'contain';
                layoutCanvas.style.backgroundRepeat = 'no-repeat';
                layoutCanvas.style.backgroundPosition = 'center';
                imageStatus.textContent = `Plano cargado: ${file.name}`;
                state.backgroundImage = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function renderPdfToCanvas(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: 1.5 });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            await page.render({ canvasContext: context, viewport }).promise;
            const dataUrl = canvas.toDataURL('image/png');
            layoutCanvas.style.backgroundImage = `url(${dataUrl})`;
            layoutCanvas.style.backgroundSize = 'contain';
            layoutCanvas.style.backgroundRepeat = 'no-repeat';
            layoutCanvas.style.backgroundPosition = 'center';
            imageStatus.textContent = `PDF importado: ${file.name}`;
            state.backgroundImage = dataUrl;
        }

        function exportLayoutAsJson() {
            const exportData = {
                metadata: {
                    widthMeters: state.widthMeters,
                    heightMeters: state.heightMeters,
                    scalePxPerMeter: state.scale,
                    generatedAt: new Date().toISOString(),
                    backgroundImage: state.backgroundImage
                },
                areas: state.areas.map(area => ({
                    id: area.id,
                    shape: area.shape,
                    x: area.x,
                    y: area.y,
                    width: area.width,
                    height: area.height,
                    points: area.points,
                    category: area.category,
                    categoryLabel: CATEGORY_DEFINITIONS.find(c => c.key === area.category)?.label || area.category,
                    type: area.type,
                    name: area.name,
                    color: area.color,
                    capacity: area.capacity,
                    processTime: area.processTime,
                    waitTime: area.waitTime,
                    notes: area.notes
                }))
            };
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `layout_hospitalario_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        init();
    </script>
</body>
</html>
